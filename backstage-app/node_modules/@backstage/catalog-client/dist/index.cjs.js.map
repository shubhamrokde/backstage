{"version":3,"file":"index.cjs.js","sources":["../src/types/api.ts","../src/CatalogClient.ts","../src/types/status.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CompoundEntityRef, Entity } from '@backstage/catalog-model';\n\n/**\n * This symbol can be used in place of a value when passed to filters in e.g.\n * {@link CatalogClient.getEntities}, to signify that you want to filter on the\n * presence of that key no matter what its value is.\n *\n * @public\n */\nexport const CATALOG_FILTER_EXISTS = Symbol.for(\n  // Random UUID to ensure no collisions\n  'CATALOG_FILTER_EXISTS_0e15b590c0b343a2bae3e787e84c2111',\n);\n\n/**\n * The request type for {@link CatalogClient.getEntities}.\n *\n * @public\n */\nexport interface GetEntitiesRequest {\n  /**\n   * If given, return only entities that match the given patterns.\n   *\n   * @remarks\n   *\n   * If multiple filter sets are given as an array, then there is effectively an\n   * OR between each filter set.\n   *\n   * Within one filter set, there is effectively an AND between the various\n   * keys.\n   *\n   * Within one key, if there are more than one value, then there is effectively\n   * an OR between them.\n   *\n   * Example: For an input of\n   *\n   * ```\n   * [\n   *   { kind: ['API', 'Component'] },\n   *   { 'metadata.name': 'a', 'metadata.namespace': 'b' }\n   * ]\n   * ```\n   *\n   * This effectively means\n   *\n   * ```\n   * (kind = EITHER 'API' OR 'Component')\n   * OR\n   * (metadata.name = 'a' AND metadata.namespace = 'b' )\n   * ```\n   *\n   * Each key is a dot separated path in each object.\n   *\n   * As a value you can also pass in the symbol `CATALOG_FILTER_EXISTS`\n   * (exported from this package), which means that you assert on the existence\n   * of that key, no matter what its value is.\n   */\n  filter?:\n    | Record<string, string | symbol | (string | symbol)[]>[]\n    | Record<string, string | symbol | (string | symbol)[]>\n    | undefined;\n  /**\n   * If given, return only the parts of each entity that match those dot\n   * separated paths in each object.\n   *\n   * @remarks\n   *\n   * Example: For an input of `['kind', 'metadata.annotations']`, then response\n   * objects will be shaped like\n   *\n   * ```\n   * {\n   *   \"kind\": \"Component\",\n   *   \"metadata\": {\n   *     \"annotations\": {\n   *       \"foo\": \"bar\"\n   *     }\n   *   }\n   * }\n   * ```\n   */\n  fields?: string[] | undefined;\n  /**\n   * If given, skips over the first N items in the result set.\n   */\n  offset?: number;\n  /**\n   * If given, returns at most N items from the result set.\n   */\n  limit?: number;\n  /**\n   * If given, skips over all items before that cursor as returned by a previous\n   * request.\n   */\n  after?: string;\n}\n\n/**\n * The response type for {@link CatalogClient.getEntities}.\n *\n * @public\n */\nexport interface GetEntitiesResponse {\n  items: Entity[];\n}\n\n/**\n * The request type for {@link CatalogClient.getEntityAncestors}.\n *\n * @public\n */\nexport interface GetEntityAncestorsRequest {\n  entityRef: string;\n}\n\n/**\n * The response type for {@link CatalogClient.getEntityAncestors}.\n *\n * @public\n */\nexport interface GetEntityAncestorsResponse {\n  rootEntityRef: string;\n  items: Array<{\n    entity: Entity;\n    parentEntityRefs: string[];\n  }>;\n}\n\n/**\n * The request type for {@link CatalogClient.getEntityFacets}.\n *\n * @public\n */\nexport interface GetEntityFacetsRequest {\n  /**\n   * If given, return only entities that match the given patterns.\n   *\n   * @remarks\n   *\n   * If multiple filter sets are given as an array, then there is effectively an\n   * OR between each filter set.\n   *\n   * Within one filter set, there is effectively an AND between the various\n   * keys.\n   *\n   * Within one key, if there are more than one value, then there is effectively\n   * an OR between them.\n   *\n   * Example: For an input of\n   *\n   * ```\n   * [\n   *   { kind: ['API', 'Component'] },\n   *   { 'metadata.name': 'a', 'metadata.namespace': 'b' }\n   * ]\n   * ```\n   *\n   * This effectively means\n   *\n   * ```\n   * (kind = EITHER 'API' OR 'Component')\n   * OR\n   * (metadata.name = 'a' AND metadata.namespace = 'b' )\n   * ```\n   *\n   * Each key is a dot separated path in each object.\n   *\n   * As a value you can also pass in the symbol `CATALOG_FILTER_EXISTS`\n   * (exported from this package), which means that you assert on the existence\n   * of that key, no matter what its value is.\n   */\n  filter?:\n    | Record<string, string | symbol | (string | symbol)[]>[]\n    | Record<string, string | symbol | (string | symbol)[]>\n    | undefined;\n  /**\n   * Dot separated paths for the facets to extract from each entity.\n   *\n   * @remarks\n   *\n   * Example: For an input of `['kind', 'metadata.annotations.backstage.io/orphan']`, then the\n   * response will be shaped like\n   *\n   * ```\n   * {\n   *   \"facets\": {\n   *     \"kind\": [\n   *       { \"key\": \"Component\", \"count\": 22 },\n   *       { \"key\": \"API\", \"count\": 13 }\n   *     ],\n   *     \"metadata.annotations.backstage.io/orphan\": [\n   *       { \"key\": \"true\", \"count\": 2 }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  facets: string[];\n}\n\n/**\n * The response type for {@link CatalogClient.getEntityFacets}.\n *\n * @public\n */\nexport interface GetEntityFacetsResponse {\n  /**\n   * The computed facets, one entry per facet in the request.\n   */\n  facets: Record<string, Array<{ value: string; count: number }>>;\n}\n\n/**\n * Options you can pass into a catalog request for additional information.\n *\n * @public\n */\nexport interface CatalogRequestOptions {\n  token?: string;\n}\n\n/**\n * Entity location for a specific entity.\n *\n * @public\n */\nexport type Location = {\n  id: string;\n  type: string;\n  target: string;\n};\n\n/**\n * The request type for {@link CatalogClient.addLocation}.\n *\n * @public\n */\nexport type AddLocationRequest = {\n  type?: string;\n  target: string;\n  dryRun?: boolean;\n};\n\n/**\n * The response type for {@link CatalogClient.addLocation}.\n *\n * @public\n */\nexport type AddLocationResponse = {\n  location: Location;\n  entities: Entity[];\n  // Only set in dryRun mode.\n  exists?: boolean;\n};\n\n/**\n * A client for interacting with the Backstage software catalog through its API.\n *\n * @public\n */\nexport interface CatalogApi {\n  /**\n   * Lists catalog entities.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntities(\n    request?: GetEntitiesRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntitiesResponse>;\n\n  /**\n   * Gets entity ancestor information, i.e. the hierarchy of parent entities\n   * whose processing resulted in a given entity appearing in the catalog.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntityAncestors(\n    request: GetEntityAncestorsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityAncestorsResponse>;\n\n  /**\n   * Gets a single entity from the catalog by its ref (kind, namespace, name)\n   * triplet.\n   *\n   * @param entityRef - A complete entity ref, either on string or compound form\n   * @param options - Additional options\n   * @returns The matching entity, or undefined if there was no entity with that ref\n   */\n  getEntityByRef(\n    entityRef: string | CompoundEntityRef,\n    options?: CatalogRequestOptions,\n  ): Promise<Entity | undefined>;\n\n  /**\n   * Removes a single entity from the catalog by entity UID.\n   *\n   * @param uid - An entity UID\n   * @param options - Additional options\n   */\n  removeEntityByUid(\n    uid: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n\n  /**\n   * Refreshes (marks for reprocessing) an entity in the catalog.\n   *\n   * @param entityRef - An entity ref on string form (e.g.\n   *        'component/default:my-component')\n   * @param options - Additional options\n   */\n  refreshEntity(\n    entityRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n\n  /**\n   * Gets a summary of field facets of entities in the catalog.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntityFacets(\n    request: GetEntityFacetsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityFacetsResponse>;\n\n  // Locations\n\n  /**\n   * Gets a registered location by its ID.\n   *\n   * @param id - A location ID\n   * @param options - Additional options\n   */\n  getLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined>;\n\n  /**\n   * Gets a registered location by its ref.\n   *\n   * @param locationRef - A location ref, e.g. \"url:https://github.com/...\"\n   * @param options - Additional options\n   */\n  getLocationByRef(\n    locationRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined>;\n\n  /**\n   * Registers a new location.\n   *\n   * @param location - Request parameters\n   * @param options - Additional options\n   */\n  addLocation(\n    location: AddLocationRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<AddLocationResponse>;\n\n  /**\n   * Removes a registered Location by its ID.\n   *\n   * @param id - A location ID\n   * @param options - Additional options\n   */\n  removeLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Entity,\n  CompoundEntityRef,\n  parseEntityRef,\n  stringifyEntityRef,\n  stringifyLocationRef,\n} from '@backstage/catalog-model';\nimport { ResponseError } from '@backstage/errors';\nimport crossFetch from 'cross-fetch';\nimport {\n  CATALOG_FILTER_EXISTS,\n  AddLocationRequest,\n  AddLocationResponse,\n  CatalogApi,\n  GetEntitiesRequest,\n  GetEntitiesResponse,\n  CatalogRequestOptions,\n  GetEntityAncestorsRequest,\n  GetEntityAncestorsResponse,\n  Location,\n  GetEntityFacetsRequest,\n  GetEntityFacetsResponse,\n} from './types/api';\nimport { DiscoveryApi } from './types/discovery';\nimport { FetchApi } from './types/fetch';\n\n/**\n * A frontend and backend compatible client for communicating with the Backstage\n * software catalog.\n *\n * @public\n */\nexport class CatalogClient implements CatalogApi {\n  private readonly discoveryApi: DiscoveryApi;\n  private readonly fetchApi: FetchApi;\n\n  constructor(options: {\n    discoveryApi: { getBaseUrl(pluginId: string): Promise<string> };\n    fetchApi?: { fetch: typeof fetch };\n  }) {\n    this.discoveryApi = options.discoveryApi;\n    this.fetchApi = options.fetchApi || { fetch: crossFetch };\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntityAncestors}\n   */\n  async getEntityAncestors(\n    request: GetEntityAncestorsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityAncestorsResponse> {\n    const { kind, namespace, name } = parseEntityRef(request.entityRef);\n    return await this.requestRequired(\n      'GET',\n      `/entities/by-name/${encodeURIComponent(kind)}/${encodeURIComponent(\n        namespace,\n      )}/${encodeURIComponent(name)}/ancestry`,\n      options,\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getLocationById}\n   */\n  async getLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined> {\n    return await this.requestOptional(\n      'GET',\n      `/locations/${encodeURIComponent(id)}`,\n      options,\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntities}\n   */\n  async getEntities(\n    request?: GetEntitiesRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntitiesResponse> {\n    const { filter = [], fields = [], offset, limit, after } = request ?? {};\n    const params: string[] = [];\n\n    // filter param can occur multiple times, for example\n    // /api/catalog/entities?filter=metadata.name=wayback-search,kind=component&filter=metadata.name=www-artist,kind=component'\n    // the \"outer array\" defined by `filter` occurrences corresponds to \"anyOf\" filters\n    // the \"inner array\" defined within a `filter` param corresponds to \"allOf\" filters\n    for (const filterItem of [filter].flat()) {\n      const filterParts: string[] = [];\n      for (const [key, value] of Object.entries(filterItem)) {\n        for (const v of [value].flat()) {\n          if (v === CATALOG_FILTER_EXISTS) {\n            filterParts.push(encodeURIComponent(key));\n          } else if (typeof v === 'string') {\n            filterParts.push(\n              `${encodeURIComponent(key)}=${encodeURIComponent(v)}`,\n            );\n          }\n        }\n      }\n\n      if (filterParts.length) {\n        params.push(`filter=${filterParts.join(',')}`);\n      }\n    }\n\n    if (fields.length) {\n      params.push(`fields=${fields.map(encodeURIComponent).join(',')}`);\n    }\n\n    if (offset !== undefined) {\n      params.push(`offset=${offset}`);\n    }\n    if (limit !== undefined) {\n      params.push(`limit=${limit}`);\n    }\n    if (after !== undefined) {\n      params.push(`after=${encodeURIComponent(after)}`);\n    }\n\n    const query = params.length ? `?${params.join('&')}` : '';\n    const entities: Entity[] = await this.requestRequired(\n      'GET',\n      `/entities${query}`,\n      options,\n    );\n\n    const refCompare = (a: Entity, b: Entity) => {\n      // in case field filtering is used, these fields might not be part of the response\n      if (\n        a.metadata?.name === undefined ||\n        a.kind === undefined ||\n        b.metadata?.name === undefined ||\n        b.kind === undefined\n      ) {\n        return 0;\n      }\n\n      const aRef = stringifyEntityRef(a);\n      const bRef = stringifyEntityRef(b);\n      if (aRef < bRef) {\n        return -1;\n      }\n      if (aRef > bRef) {\n        return 1;\n      }\n      return 0;\n    };\n\n    return { items: entities.sort(refCompare) };\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntityByRef}\n   */\n  async getEntityByRef(\n    entityRef: string | CompoundEntityRef,\n    options?: CatalogRequestOptions,\n  ): Promise<Entity | undefined> {\n    const { kind, namespace, name } = parseEntityRef(entityRef);\n    return this.requestOptional(\n      'GET',\n      `/entities/by-name/${encodeURIComponent(kind)}/${encodeURIComponent(\n        namespace,\n      )}/${encodeURIComponent(name)}`,\n      options,\n    );\n  }\n\n  // NOTE(freben): When we deprecate getEntityByName from the interface, we may\n  // still want to leave this implementation in place for quite some time\n  // longer, to minimize the risk for breakages. Suggested date for removal:\n  // August 2022\n  /**\n   * @deprecated Use getEntityByRef instead\n   */\n  async getEntityByName(\n    compoundName: CompoundEntityRef,\n    options?: CatalogRequestOptions,\n  ): Promise<Entity | undefined> {\n    const { kind, namespace = 'default', name } = compoundName;\n    return this.requestOptional(\n      'GET',\n      `/entities/by-name/${encodeURIComponent(kind)}/${encodeURIComponent(\n        namespace,\n      )}/${encodeURIComponent(name)}`,\n      options,\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.refreshEntity}\n   */\n  async refreshEntity(entityRef: string, options?: CatalogRequestOptions) {\n    const response = await this.fetchApi.fetch(\n      `${await this.discoveryApi.getBaseUrl('catalog')}/refresh`,\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n        },\n        method: 'POST',\n        body: JSON.stringify({ entityRef }),\n      },\n    );\n\n    if (response.status !== 200) {\n      throw new Error(await response.text());\n    }\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntityFacets}\n   */\n  async getEntityFacets(\n    request: GetEntityFacetsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityFacetsResponse> {\n    const { filter = [], facets } = request;\n    const params: string[] = [];\n\n    // filter param can occur multiple times, for example\n    // /api/catalog/entities?filter=metadata.name=wayback-search,kind=component&filter=metadata.name=www-artist,kind=component'\n    // the \"outer array\" defined by `filter` occurrences corresponds to \"anyOf\" filters\n    // the \"inner array\" defined within a `filter` param corresponds to \"allOf\" filters\n    for (const filterItem of [filter].flat()) {\n      const filterParts: string[] = [];\n      for (const [key, value] of Object.entries(filterItem)) {\n        for (const v of [value].flat()) {\n          if (v === CATALOG_FILTER_EXISTS) {\n            filterParts.push(encodeURIComponent(key));\n          } else if (typeof v === 'string') {\n            filterParts.push(\n              `${encodeURIComponent(key)}=${encodeURIComponent(v)}`,\n            );\n          }\n        }\n      }\n\n      if (filterParts.length) {\n        params.push(`filter=${filterParts.join(',')}`);\n      }\n    }\n\n    for (const facet of facets) {\n      params.push(`facet=${encodeURIComponent(facet)}`);\n    }\n\n    const query = params.length ? `?${params.join('&')}` : '';\n    return await this.requestOptional('GET', `/entity-facets${query}`, options);\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.addLocation}\n   */\n  async addLocation(\n    { type = 'url', target, dryRun }: AddLocationRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<AddLocationResponse> {\n    const response = await this.fetchApi.fetch(\n      `${await this.discoveryApi.getBaseUrl('catalog')}/locations${\n        dryRun ? '?dryRun=true' : ''\n      }`,\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n        },\n        method: 'POST',\n        body: JSON.stringify({ type, target }),\n      },\n    );\n\n    if (response.status !== 201) {\n      throw new Error(await response.text());\n    }\n\n    const { location, entities, exists } = await response.json();\n\n    if (!location) {\n      throw new Error(`Location wasn't added: ${target}`);\n    }\n\n    return {\n      location,\n      entities,\n      exists,\n    };\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getLocationByRef}\n   */\n  async getLocationByRef(\n    locationRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined> {\n    const all: { data: Location }[] = await this.requestRequired(\n      'GET',\n      '/locations',\n      options,\n    );\n    return all\n      .map(r => r.data)\n      .find(l => locationRef === stringifyLocationRef(l));\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.removeLocationById}\n   */\n  async removeLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void> {\n    await this.requestIgnored(\n      'DELETE',\n      `/locations/${encodeURIComponent(id)}`,\n      options,\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.removeEntityByUid}\n   */\n  async removeEntityByUid(\n    uid: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void> {\n    await this.requestIgnored(\n      'DELETE',\n      `/entities/by-uid/${encodeURIComponent(uid)}`,\n      options,\n    );\n  }\n\n  //\n  // Private methods\n  //\n\n  private async requestIgnored(\n    method: string,\n    path: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void> {\n    const url = `${await this.discoveryApi.getBaseUrl('catalog')}${path}`;\n    const headers: Record<string, string> = options?.token\n      ? { Authorization: `Bearer ${options.token}` }\n      : {};\n    const response = await this.fetchApi.fetch(url, { method, headers });\n\n    if (!response.ok) {\n      throw await ResponseError.fromResponse(response);\n    }\n  }\n\n  private async requestRequired(\n    method: string,\n    path: string,\n    options?: CatalogRequestOptions,\n  ): Promise<any> {\n    const url = `${await this.discoveryApi.getBaseUrl('catalog')}${path}`;\n    const headers: Record<string, string> = options?.token\n      ? { Authorization: `Bearer ${options.token}` }\n      : {};\n    const response = await this.fetchApi.fetch(url, { method, headers });\n\n    if (!response.ok) {\n      throw await ResponseError.fromResponse(response);\n    }\n\n    return await response.json();\n  }\n\n  private async requestOptional(\n    method: string,\n    path: string,\n    options?: CatalogRequestOptions,\n  ): Promise<any | undefined> {\n    const url = `${await this.discoveryApi.getBaseUrl('catalog')}${path}`;\n    const headers: Record<string, string> = options?.token\n      ? { Authorization: `Bearer ${options.token}` }\n      : {};\n    const response = await this.fetchApi.fetch(url, { method, headers });\n\n    if (!response.ok) {\n      if (response.status === 404) {\n        return undefined;\n      }\n      throw await ResponseError.fromResponse(response);\n    }\n\n    return await response.json();\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The entity `status.items[].type` for the status of the processing engine in\n * regards to an entity.\n *\n * @public\n */\nexport const ENTITY_STATUS_CATALOG_PROCESSING_TYPE =\n  'backstage.io/catalog-processing';\n"],"names":["crossFetch","parseEntityRef","stringifyEntityRef","stringifyLocationRef","ResponseError"],"mappings":"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"}