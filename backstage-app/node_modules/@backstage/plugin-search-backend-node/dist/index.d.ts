/// <reference types="node" />
import { SearchEngine, DocumentCollatorFactory, DocumentDecoratorFactory, DocumentTypeInfo, IndexableDocument, SearchQuery, QueryTranslator, SearchResultSet } from '@backstage/plugin-search-common';
export { SearchEngine } from '@backstage/plugin-search-common';
import { Logger } from 'winston';
import lunr from 'lunr';
import { Writable, Transform, Readable } from 'stream';

/**
 * @beta
 */
declare type IndexBuilderOptions = {
    searchEngine: SearchEngine;
    logger: Logger;
};
/**
 * Parameters required to register a collator.
 * @beta
 */
interface RegisterCollatorParameters {
    /**
     * The default interval (in seconds) that the provided collator will be called (can be overridden in config).
     */
    defaultRefreshIntervalSeconds: number;
    /**
     * The class responsible for returning the document collator of the given type.
     */
    factory: DocumentCollatorFactory;
}
/**
 * Parameters required to register a decorator
 * @beta
 */
interface RegisterDecoratorParameters {
    /**
     * The class responsible for returning the decorator which appends, modifies, or filters documents.
     */
    factory: DocumentDecoratorFactory;
}

/**
 * @beta
 */
declare class IndexBuilder {
    private collators;
    private decorators;
    private documentTypes;
    private searchEngine;
    private logger;
    constructor({ logger, searchEngine }: IndexBuilderOptions);
    getSearchEngine(): SearchEngine;
    getDocumentTypes(): Record<string, DocumentTypeInfo>;
    /**
     * Makes the index builder aware of a collator that should be executed at the
     * given refresh interval.
     */
    addCollator({ factory, defaultRefreshIntervalSeconds, }: RegisterCollatorParameters): void;
    /**
     * Makes the index builder aware of a decorator. If no types are provided on
     * the decorator, it will be applied to documents from all known collators,
     * otherwise it will only be applied to documents of the given types.
     */
    addDecorator({ factory }: RegisterDecoratorParameters): void;
    /**
     * Compiles collators and decorators into tasks, which are added to a
     * scheduler returned to the caller.
     */
    build(): Promise<{
        scheduler: Scheduler;
    }>;
}

/**
 * TODO: coordination, error handling
 */
/**
 * @beta
 */
declare class Scheduler {
    private logger;
    private schedule;
    private runningTasks;
    constructor({ logger }: {
        logger: Logger;
    });
    /**
     * Adds each task and interval to the schedule.
     * When running the tasks, the scheduler waits at least for the time specified
     * in the interval once the task was completed, before running it again.
     */
    addToSchedule(task: Function, interval: number): void;
    /**
     * Starts the scheduling process for each task
     */
    start(): void;
    /**
     * Stop all scheduled tasks.
     */
    stop(): void;
}

/**
 * @beta
 */
declare type BatchSearchEngineOptions = {
    batchSize: number;
};
/**
 * Base class encapsulating batch-based stream processing. Useful as a base
 * class for search engine indexers.
 * @beta
 */
declare abstract class BatchSearchEngineIndexer extends Writable {
    private batchSize;
    private currentBatch;
    private initialized;
    constructor(options: BatchSearchEngineOptions);
    /**
     * Receives an array of indexable documents (of size this.batchSize) which
     * should be written to the search engine. This method won't be called again
     * at least until it resolves.
     */
    abstract index(documents: IndexableDocument[]): Promise<void>;
    /**
     * Any asynchronous setup tasks can be performed here.
     */
    abstract initialize(): Promise<void>;
    /**
     * Any asynchronous teardown tasks can be performed here.
     */
    abstract finalize(): Promise<void>;
}

/**
 * Base class encapsulating simple async transformations. Useful as a base
 * class for Backstage search decorators.
 * @beta
 */
declare abstract class DecoratorBase extends Transform {
    private initialized;
    constructor();
    /**
     * Any asynchronous setup tasks can be performed here.
     */
    abstract initialize(): Promise<void>;
    /**
     * Receives a single indexable document. In your decorate method, you can:
     *
     * - Resolve `undefined` to indicate the record should be omitted.
     * - Resolve a single modified document, which could contain new fields,
     *   edited fields, or removed fields.
     * - Resolve an array of indexable documents, if the purpose if the decorator
     *   is to convert one document into multiple derivative documents.
     */
    abstract decorate(document: IndexableDocument): Promise<IndexableDocument | IndexableDocument[] | undefined>;
    /**
     * Any asynchronous teardown tasks can be performed here.
     */
    abstract finalize(): Promise<void>;
}

/**
 * @beta
 */
declare class LunrSearchEngineIndexer extends BatchSearchEngineIndexer {
    private schemaInitialized;
    private builder;
    private docStore;
    constructor();
    initialize(): Promise<void>;
    finalize(): Promise<void>;
    index(documents: IndexableDocument[]): Promise<void>;
    buildIndex(): lunr.Index;
    getDocumentStore(): Record<string, IndexableDocument>;
}

/**
 * @beta
 */
declare type ConcreteLunrQuery = {
    lunrQueryBuilder: lunr.Index.QueryBuilder;
    documentTypes?: string[];
    pageSize: number;
};
/**
 * @beta
 */
declare type LunrQueryTranslator = (query: SearchQuery) => ConcreteLunrQuery;
/**
 * @beta
 */
declare class LunrSearchEngine implements SearchEngine {
    protected lunrIndices: Record<string, lunr.Index>;
    protected docStore: Record<string, IndexableDocument>;
    protected logger: Logger;
    constructor({ logger }: {
        logger: Logger;
    });
    protected translator: QueryTranslator;
    setTranslator(translator: LunrQueryTranslator): void;
    getIndexer(type: string): Promise<LunrSearchEngineIndexer>;
    query(query: SearchQuery): Promise<SearchResultSet>;
}

/**
 * Object resolved after a test pipeline is executed.
 * @beta
 */
declare type TestPipelineResult = {
    /**
     * If an error was emitted by the pipeline, it will be set here.
     */
    error: unknown;
    /**
     * A list of documents collected at the end of the pipeline. If the subject
     * under test is an indexer, this will be an empty array (because your
     * indexer should have received the documents instead).
     */
    documents: IndexableDocument[];
};
/**
 * Test utility for Backstage Search collators, decorators, and indexers.
 * @beta
 */
declare class TestPipeline {
    private collator?;
    private decorator?;
    private indexer?;
    private constructor();
    /**
     * Provide the collator, decorator, or indexer to be tested.
     */
    static withSubject(subject: Readable | Transform | Writable): TestPipeline;
    /**
     * Provide documents for testing decorators and indexers.
     */
    withDocuments(documents: IndexableDocument[]): TestPipeline;
    /**
     * Execute the test pipeline so that you can make assertions about the result
     * or behavior of the given test subject.
     */
    execute(): Promise<TestPipelineResult>;
}

export { BatchSearchEngineIndexer, BatchSearchEngineOptions, ConcreteLunrQuery, DecoratorBase, IndexBuilder, IndexBuilderOptions, LunrQueryTranslator, LunrSearchEngine, LunrSearchEngineIndexer, RegisterCollatorParameters, RegisterDecoratorParameters, Scheduler, TestPipeline, TestPipelineResult };
