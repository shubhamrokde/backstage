{"version":3,"file":"index.cjs.js","sources":["../src/IndexBuilder.ts","../src/runPeriodically.ts","../src/Scheduler.ts","../src/indexing/BatchSearchEngineIndexer.ts","../src/indexing/DecoratorBase.ts","../src/engines/LunrSearchEngineIndexer.ts","../src/engines/LunrSearchEngine.ts","../src/test-utils/TestPipeline.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  DocumentCollatorFactory,\n  DocumentDecoratorFactory,\n  DocumentTypeInfo,\n  SearchEngine,\n} from '@backstage/plugin-search-common';\nimport { Transform, pipeline } from 'stream';\nimport { Logger } from 'winston';\nimport { Scheduler } from './index';\nimport {\n  IndexBuilderOptions,\n  RegisterCollatorParameters,\n  RegisterDecoratorParameters,\n} from './types';\n\ninterface CollatorEnvelope {\n  factory: DocumentCollatorFactory;\n  refreshInterval: number;\n}\n\n/**\n * @beta\n */\nexport class IndexBuilder {\n  private collators: Record<string, CollatorEnvelope>;\n  private decorators: Record<string, DocumentDecoratorFactory[]>;\n  private documentTypes: Record<string, DocumentTypeInfo>;\n  private searchEngine: SearchEngine;\n  private logger: Logger;\n\n  constructor({ logger, searchEngine }: IndexBuilderOptions) {\n    this.collators = {};\n    this.decorators = {};\n    this.documentTypes = {};\n    this.logger = logger;\n    this.searchEngine = searchEngine;\n  }\n\n  getSearchEngine(): SearchEngine {\n    return this.searchEngine;\n  }\n\n  getDocumentTypes(): Record<string, DocumentTypeInfo> {\n    return this.documentTypes;\n  }\n\n  /**\n   * Makes the index builder aware of a collator that should be executed at the\n   * given refresh interval.\n   */\n  addCollator({\n    factory,\n    defaultRefreshIntervalSeconds,\n  }: RegisterCollatorParameters): void {\n    this.logger.info(\n      `Added ${factory.constructor.name} collator factory for type ${factory.type}`,\n    );\n    this.collators[factory.type] = {\n      refreshInterval: defaultRefreshIntervalSeconds,\n      factory,\n    };\n    this.documentTypes[factory.type] = {\n      visibilityPermission: factory.visibilityPermission,\n    };\n  }\n\n  /**\n   * Makes the index builder aware of a decorator. If no types are provided on\n   * the decorator, it will be applied to documents from all known collators,\n   * otherwise it will only be applied to documents of the given types.\n   */\n  addDecorator({ factory }: RegisterDecoratorParameters): void {\n    const types = factory.types || ['*'];\n    this.logger.info(\n      `Added decorator ${factory.constructor.name} to types ${types.join(\n        ', ',\n      )}`,\n    );\n    types.forEach(type => {\n      if (this.decorators.hasOwnProperty(type)) {\n        this.decorators[type].push(factory);\n      } else {\n        this.decorators[type] = [factory];\n      }\n    });\n  }\n\n  /**\n   * Compiles collators and decorators into tasks, which are added to a\n   * scheduler returned to the caller.\n   */\n  async build(): Promise<{ scheduler: Scheduler }> {\n    const scheduler = new Scheduler({ logger: this.logger });\n\n    Object.keys(this.collators).forEach(type => {\n      scheduler.addToSchedule(async () => {\n        // Instantiate the collator.\n        const collator = await this.collators[type].factory.getCollator();\n        this.logger.info(\n          `Collating documents for ${type} via ${this.collators[type].factory.constructor.name}`,\n        );\n\n        // Instantiate all relevant decorators.\n        const decorators: Transform[] = await Promise.all(\n          (this.decorators['*'] || [])\n            .concat(this.decorators[type] || [])\n            .map(async factory => {\n              const decorator = await factory.getDecorator();\n              this.logger.info(\n                `Attached decorator via ${factory.constructor.name} to ${type} index pipeline.`,\n              );\n              return decorator;\n            }),\n        );\n\n        // Instantiate the indexer.\n        const indexer = await this.searchEngine.getIndexer(type);\n\n        // Compose collator/decorators/indexer into a pipeline\n        return new Promise<void>(done => {\n          pipeline([collator, ...decorators, indexer], error => {\n            if (error) {\n              this.logger.error(\n                `Collating documents for ${type} failed: ${error}`,\n              );\n            } else {\n              this.logger.info(`Collating documents for ${type} succeeded`);\n            }\n\n            // Signal index pipeline completion!\n            done();\n          });\n        });\n      }, this.collators[type].refreshInterval * 1000);\n    });\n\n    return {\n      scheduler,\n    };\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Runs a function repeatedly, with a fixed wait between invocations.\n *\n * Supports async functions, and silently ignores exceptions and rejections.\n *\n * @param fn - The function to run. May return a Promise.\n * @param delayMs - The delay between a completed function invocation and the\n *                next.\n * @returns A function that, when called, stops the invocation loop.\n */\nexport function runPeriodically(fn: () => any, delayMs: number): () => void {\n  let cancel: () => void;\n  let cancelled = false;\n  const cancellationPromise = new Promise<void>(resolve => {\n    cancel = () => {\n      resolve();\n      cancelled = true;\n    };\n  });\n\n  const startRefresh = async () => {\n    while (!cancelled) {\n      try {\n        await fn();\n      } catch {\n        // ignore intentionally\n      }\n\n      await Promise.race([\n        new Promise(resolve => setTimeout(resolve, delayMs)),\n        cancellationPromise,\n      ]);\n    }\n  };\n  startRefresh();\n\n  return cancel!;\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from 'winston';\nimport { runPeriodically } from './runPeriodically';\n\ntype TaskEnvelope = {\n  task: Function;\n  interval: number;\n};\n\n/**\n * TODO: coordination, error handling\n */\n\n/**\n * @beta\n */\nexport class Scheduler {\n  private logger: Logger;\n  private schedule: TaskEnvelope[];\n  private runningTasks: Function[] = [];\n\n  constructor({ logger }: { logger: Logger }) {\n    this.logger = logger;\n    this.schedule = [];\n  }\n\n  /**\n   * Adds each task and interval to the schedule.\n   * When running the tasks, the scheduler waits at least for the time specified\n   * in the interval once the task was completed, before running it again.\n   */\n  addToSchedule(task: Function, interval: number) {\n    if (this.runningTasks.length) {\n      throw new Error(\n        'Cannot add task to schedule that has already been started.',\n      );\n    }\n    this.schedule.push({ task, interval });\n  }\n\n  /**\n   * Starts the scheduling process for each task\n   */\n  start() {\n    this.logger.info('Starting all scheduled search tasks.');\n    this.schedule.forEach(({ task, interval }) => {\n      this.runningTasks.push(runPeriodically(() => task(), interval));\n    });\n  }\n\n  /**\n   * Stop all scheduled tasks.\n   */\n  stop() {\n    this.logger.info('Stopping all scheduled search tasks.');\n    this.runningTasks.forEach(cancel => {\n      cancel();\n    });\n    this.runningTasks = [];\n  }\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assertError } from '@backstage/errors';\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { Writable } from 'stream';\n\n/**\n * @beta\n */\nexport type BatchSearchEngineOptions = {\n  batchSize: number;\n};\n\n/**\n * Base class encapsulating batch-based stream processing. Useful as a base\n * class for search engine indexers.\n * @beta\n */\nexport abstract class BatchSearchEngineIndexer extends Writable {\n  private batchSize: number;\n  private currentBatch: IndexableDocument[] = [];\n  private initialized: Promise<undefined | Error>;\n\n  constructor(options: BatchSearchEngineOptions) {\n    super({ objectMode: true });\n    this.batchSize = options.batchSize;\n\n    // @todo Once node v15 is minimum, convert to _construct implementation.\n    this.initialized = new Promise(done => {\n      // Necessary to allow concrete implementation classes to construct\n      // themselves before calling their initialize() methods.\n      setImmediate(async () => {\n        try {\n          await this.initialize();\n          done(undefined);\n        } catch (e) {\n          assertError(e);\n          done(e);\n        }\n      });\n    });\n  }\n\n  /**\n   * Receives an array of indexable documents (of size this.batchSize) which\n   * should be written to the search engine. This method won't be called again\n   * at least until it resolves.\n   */\n  public abstract index(documents: IndexableDocument[]): Promise<void>;\n\n  /**\n   * Any asynchronous setup tasks can be performed here.\n   */\n  public abstract initialize(): Promise<void>;\n\n  /**\n   * Any asynchronous teardown tasks can be performed here.\n   */\n  public abstract finalize(): Promise<void>;\n\n  /**\n   * Encapsulates batch stream write logic.\n   * @internal\n   */\n  async _write(\n    doc: IndexableDocument,\n    _e: any,\n    done: (error?: Error | null) => void,\n  ) {\n    // Wait for init before proceeding. Throw error if initialization failed.\n    const maybeError = await this.initialized;\n    if (maybeError) {\n      done(maybeError);\n      return;\n    }\n\n    this.currentBatch.push(doc);\n    if (this.currentBatch.length < this.batchSize) {\n      done();\n      return;\n    }\n\n    try {\n      await this.index(this.currentBatch);\n      this.currentBatch = [];\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n\n  /**\n   * Encapsulates finalization and final error handling logic.\n   * @internal\n   */\n  async _final(done: (error?: Error | null) => void) {\n    try {\n      // Index any remaining documents.\n      if (this.currentBatch.length) {\n        await this.index(this.currentBatch);\n        this.currentBatch = [];\n      }\n      await this.finalize();\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assertError } from '@backstage/errors';\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { Transform } from 'stream';\n\n/**\n * Base class encapsulating simple async transformations. Useful as a base\n * class for Backstage search decorators.\n * @beta\n */\nexport abstract class DecoratorBase extends Transform {\n  private initialized: Promise<undefined | Error>;\n\n  constructor() {\n    super({ objectMode: true });\n\n    // @todo Once node v15 is minimum, convert to _construct implementation.\n    this.initialized = new Promise(done => {\n      // Necessary to allow concrete implementation classes to construct\n      // themselves before calling their initialize() methods.\n      setImmediate(async () => {\n        try {\n          await this.initialize();\n          done(undefined);\n        } catch (e) {\n          assertError(e);\n          done(e);\n        }\n      });\n    });\n  }\n\n  /**\n   * Any asynchronous setup tasks can be performed here.\n   */\n  public abstract initialize(): Promise<void>;\n\n  /**\n   * Receives a single indexable document. In your decorate method, you can:\n   *\n   * - Resolve `undefined` to indicate the record should be omitted.\n   * - Resolve a single modified document, which could contain new fields,\n   *   edited fields, or removed fields.\n   * - Resolve an array of indexable documents, if the purpose if the decorator\n   *   is to convert one document into multiple derivative documents.\n   */\n  public abstract decorate(\n    document: IndexableDocument,\n  ): Promise<IndexableDocument | IndexableDocument[] | undefined>;\n\n  /**\n   * Any asynchronous teardown tasks can be performed here.\n   */\n  public abstract finalize(): Promise<void>;\n\n  /**\n   * Encapsulates simple transform stream logic.\n   * @internal\n   */\n  async _transform(\n    document: IndexableDocument,\n    _: any,\n    done: (error?: Error | null) => void,\n  ) {\n    // Wait for init before proceeding. Throw error if initialization failed.\n    const maybeError = await this.initialized;\n    if (maybeError) {\n      done(maybeError);\n      return;\n    }\n\n    try {\n      const decorated = await this.decorate(document);\n\n      // If undefined was returned, omit the record and move on.\n      if (decorated === undefined) {\n        done();\n        return;\n      }\n\n      // If an array of documents was given, push them all.\n      if (Array.isArray(decorated)) {\n        decorated.forEach(doc => {\n          this.push(doc);\n        });\n        done();\n        return;\n      }\n\n      // Otherwise, just push the decorated document.\n      this.push(decorated);\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n\n  /**\n   * Encapsulates finalization and final error handling logic.\n   * @internal\n   */\n  async _final(done: (error?: Error | null) => void) {\n    try {\n      await this.finalize();\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport lunr from 'lunr';\nimport { BatchSearchEngineIndexer } from '../indexing';\n\n/**\n * @beta\n */\nexport class LunrSearchEngineIndexer extends BatchSearchEngineIndexer {\n  private schemaInitialized = false;\n  private builder: lunr.Builder;\n  private docStore: Record<string, IndexableDocument> = {};\n\n  constructor() {\n    super({ batchSize: 100 });\n\n    this.builder = new lunr.Builder();\n    this.builder.pipeline.add(lunr.trimmer, lunr.stopWordFilter, lunr.stemmer);\n    this.builder.searchPipeline.add(lunr.stemmer);\n  }\n\n  // No async initialization required.\n  async initialize(): Promise<void> {}\n  async finalize(): Promise<void> {}\n\n  async index(documents: IndexableDocument[]): Promise<void> {\n    if (!this.schemaInitialized) {\n      // Make this lunr index aware of all relevant fields.\n      Object.keys(documents[0]).forEach(field => {\n        this.builder.field(field);\n      });\n\n      // Set \"location\" field as reference field\n      this.builder.ref('location');\n\n      this.schemaInitialized = true;\n    }\n\n    documents.forEach(document => {\n      // Add document to Lunar index\n      this.builder.add(document);\n\n      // Store documents in memory to be able to look up document using the ref during query time\n      // This is not how you should implement your SearchEngine implementation! Do not copy!\n      this.docStore[document.location] = document;\n    });\n  }\n\n  buildIndex() {\n    return this.builder.build();\n  }\n\n  getDocumentStore() {\n    return this.docStore;\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  IndexableDocument,\n  SearchQuery,\n  SearchResultSet,\n  QueryTranslator,\n  SearchEngine,\n} from '@backstage/plugin-search-common';\nimport lunr from 'lunr';\nimport { Logger } from 'winston';\nimport { LunrSearchEngineIndexer } from './LunrSearchEngineIndexer';\n\n/**\n * @beta\n */\nexport type ConcreteLunrQuery = {\n  lunrQueryBuilder: lunr.Index.QueryBuilder;\n  documentTypes?: string[];\n  pageSize: number;\n};\n\ntype LunrResultEnvelope = {\n  result: lunr.Index.Result;\n  type: string;\n};\n\n/**\n * @beta\n */\nexport type LunrQueryTranslator = (query: SearchQuery) => ConcreteLunrQuery;\n\n/**\n * @beta\n */\nexport class LunrSearchEngine implements SearchEngine {\n  protected lunrIndices: Record<string, lunr.Index> = {};\n  protected docStore: Record<string, IndexableDocument>;\n  protected logger: Logger;\n\n  constructor({ logger }: { logger: Logger }) {\n    this.logger = logger;\n    this.docStore = {};\n  }\n\n  protected translator: QueryTranslator = ({\n    term,\n    filters,\n    types,\n  }: SearchQuery): ConcreteLunrQuery => {\n    const pageSize = 25;\n\n    return {\n      lunrQueryBuilder: q => {\n        const termToken = lunr.tokenizer(term);\n\n        // Support for typeahead search is based on https://github.com/olivernn/lunr.js/issues/256#issuecomment-295407852\n        // look for an exact match and apply a large positive boost\n        q.term(termToken, {\n          usePipeline: true,\n          boost: 100,\n        });\n        // look for terms that match the beginning of this term and apply a\n        // medium boost\n        q.term(termToken, {\n          usePipeline: false,\n          boost: 10,\n          wildcard: lunr.Query.wildcard.TRAILING,\n        });\n        // look for terms that match with an edit distance of 2 and apply a\n        // small boost\n        q.term(termToken, {\n          usePipeline: false,\n          editDistance: 2,\n          boost: 1,\n        });\n\n        if (filters) {\n          Object.entries(filters).forEach(([field, fieldValue]) => {\n            if (!q.allFields.includes(field)) {\n              // Throw for unknown field, as this will be a non match\n              throw new Error(`unrecognised field ${field}`);\n            }\n            // Arrays are poorly supported, but we can make it better for single-item arrays,\n            // which should be a common case\n            const value =\n              Array.isArray(fieldValue) && fieldValue.length === 1\n                ? fieldValue[0]\n                : fieldValue;\n\n            // Require that the given field has the given value\n            if (['string', 'number', 'boolean'].includes(typeof value)) {\n              q.term(lunr.tokenizer(value?.toString()), {\n                presence: lunr.Query.presence.REQUIRED,\n                fields: [field],\n              });\n            } else if (Array.isArray(value)) {\n              // Illustrate how multi-value filters could work.\n              // But warn that Lurn supports this poorly.\n              this.logger.warn(\n                `Non-scalar filter value used for field ${field}. Consider using a different Search Engine for better results.`,\n              );\n              q.term(lunr.tokenizer(value), {\n                presence: lunr.Query.presence.OPTIONAL,\n                fields: [field],\n              });\n            } else {\n              // Log a warning or something about unknown filter value\n              this.logger.warn(`Unknown filter type used on field ${field}`);\n            }\n          });\n        }\n      },\n      documentTypes: types,\n      pageSize,\n    };\n  };\n\n  setTranslator(translator: LunrQueryTranslator) {\n    this.translator = translator;\n  }\n\n  async getIndexer(type: string) {\n    const indexer = new LunrSearchEngineIndexer();\n\n    indexer.on('close', () => {\n      // Once the stream is closed, build the index and store the documents in\n      // memory for later retrieval.\n      this.lunrIndices[type] = indexer.buildIndex();\n      this.docStore = { ...this.docStore, ...indexer.getDocumentStore() };\n    });\n\n    return indexer;\n  }\n\n  async query(query: SearchQuery): Promise<SearchResultSet> {\n    const { lunrQueryBuilder, documentTypes, pageSize } = this.translator(\n      query,\n    ) as ConcreteLunrQuery;\n\n    const results: LunrResultEnvelope[] = [];\n\n    // Iterate over the filtered list of this.lunrIndex keys.\n    Object.keys(this.lunrIndices)\n      .filter(type => !documentTypes || documentTypes.includes(type))\n      .forEach(type => {\n        try {\n          results.push(\n            ...this.lunrIndices[type].query(lunrQueryBuilder).map(result => {\n              return {\n                result: result,\n                type: type,\n              };\n            }),\n          );\n        } catch (err) {\n          // if a field does not exist on a index, we can see that as a no-match\n          if (\n            err instanceof Error &&\n            err.message.startsWith('unrecognised field')\n          ) {\n            return;\n          }\n          throw err;\n        }\n      });\n\n    // Sort results.\n    results.sort((doc1, doc2) => {\n      return doc2.result.score - doc1.result.score;\n    });\n\n    // Perform paging\n    const { page } = decodePageCursor(query.pageCursor);\n    const offset = page * pageSize;\n    const hasPreviousPage = page > 0;\n    const hasNextPage = results.length > offset + pageSize;\n    const nextPageCursor = hasNextPage\n      ? encodePageCursor({ page: page + 1 })\n      : undefined;\n    const previousPageCursor = hasPreviousPage\n      ? encodePageCursor({ page: page - 1 })\n      : undefined;\n\n    // Translate results into SearchResultSet\n    const realResultSet: SearchResultSet = {\n      results: results.slice(offset, offset + pageSize).map(d => {\n        return { type: d.type, document: this.docStore[d.result.ref] };\n      }),\n      nextPageCursor,\n      previousPageCursor,\n    };\n\n    return realResultSet;\n  }\n}\n\nexport function decodePageCursor(pageCursor?: string): { page: number } {\n  if (!pageCursor) {\n    return { page: 0 };\n  }\n\n  return {\n    page: Number(Buffer.from(pageCursor, 'base64').toString('utf-8')),\n  };\n}\n\nexport function encodePageCursor({ page }: { page: number }): string {\n  return Buffer.from(`${page}`, 'utf-8').toString('base64');\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { pipeline, Readable, Transform, Writable } from 'stream';\n\n/**\n * Object resolved after a test pipeline is executed.\n * @beta\n */\nexport type TestPipelineResult = {\n  /**\n   * If an error was emitted by the pipeline, it will be set here.\n   */\n  error: unknown;\n\n  /**\n   * A list of documents collected at the end of the pipeline. If the subject\n   * under test is an indexer, this will be an empty array (because your\n   * indexer should have received the documents instead).\n   */\n  documents: IndexableDocument[];\n};\n\n/**\n * Test utility for Backstage Search collators, decorators, and indexers.\n * @beta\n */\nexport class TestPipeline {\n  private collator?: Readable;\n  private decorator?: Transform;\n  private indexer?: Writable;\n\n  private constructor({\n    collator,\n    decorator,\n    indexer,\n  }: {\n    collator?: Readable;\n    decorator?: Transform;\n    indexer?: Writable;\n  }) {\n    this.collator = collator;\n    this.decorator = decorator;\n    this.indexer = indexer;\n  }\n\n  /**\n   * Provide the collator, decorator, or indexer to be tested.\n   */\n  static withSubject(subject: Readable | Transform | Writable) {\n    if (subject instanceof Transform) {\n      return new TestPipeline({ decorator: subject });\n    }\n\n    if (subject instanceof Readable) {\n      return new TestPipeline({ collator: subject });\n    }\n\n    if (subject instanceof Writable) {\n      return new TestPipeline({ indexer: subject });\n    }\n\n    throw new Error(\n      'Unknown test subject: are you passing a readable, writable, or transform stream?',\n    );\n  }\n\n  /**\n   * Provide documents for testing decorators and indexers.\n   */\n  withDocuments(documents: IndexableDocument[]): TestPipeline {\n    if (this.collator) {\n      throw new Error('Cannot provide documents when testing a collator.');\n    }\n\n    // Set a naive readable stream that just pushes all given documents.\n    this.collator = new Readable({ objectMode: true });\n    this.collator._read = () => {};\n    process.nextTick(() => {\n      documents.forEach(document => {\n        this.collator!.push(document);\n      });\n      this.collator!.push(null);\n    });\n\n    return this;\n  }\n\n  /**\n   * Execute the test pipeline so that you can make assertions about the result\n   * or behavior of the given test subject.\n   */\n  async execute(): Promise<TestPipelineResult> {\n    const documents: IndexableDocument[] = [];\n    if (!this.collator) {\n      throw new Error(\n        'Cannot execute pipeline without a collator or documents',\n      );\n    }\n\n    // If we are here and there is no indexer, we are testing a collator or a\n    // decorator. Set up a naive writable that captures documents in memory.\n    if (!this.indexer) {\n      this.indexer = new Writable({ objectMode: true });\n      this.indexer._write = (document: IndexableDocument, _, done) => {\n        documents.push(document);\n        done();\n      };\n    }\n\n    return new Promise<TestPipelineResult>(done => {\n      const pipes: (Readable | Transform | Writable)[] = [this.collator!];\n      if (this.decorator) {\n        pipes.push(this.decorator);\n      }\n      pipes.push(this.indexer!);\n\n      pipeline(pipes, error => {\n        done({\n          error,\n          documents,\n        });\n      });\n    });\n  }\n}\n"],"names":["pipeline","Writable","assertError","Transform","lunr","Readable"],"mappings":"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"}