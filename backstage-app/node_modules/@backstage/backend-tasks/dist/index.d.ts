import { DatabaseManager } from '@backstage/backend-common';
import { Config } from '@backstage/config';
import { Logger } from 'winston';
import { Duration } from 'luxon';
import { AbortSignal } from 'node-abort-controller';

/**
 * A function that can be called as a scheduled task.
 *
 * It may optionally accept an abort signal argument. When the signal triggers,
 * processing should abort and return as quickly as possible.
 *
 * @public
 */
declare type TaskFunction = ((abortSignal: AbortSignal) => void | Promise<void>) | (() => void | Promise<void>);
/**
 * Options that control the scheduling of a task.
 *
 * @public
 */
interface TaskScheduleDefinition {
    /**
     * How often you want the task to run. The system does its best to avoid
     * overlapping invocations.
     *
     * This is a best effort value; under some circumstances there can be
     * deviations. For example, if the task runtime is longer than the frequency
     * and the timeout has not been given or not been exceeded yet, the next
     * invocation of this task will be delayed until after the previous one
     * finishes.
     *
     * This is a required field.
     */
    frequency: {
        /**
         * A crontab style string.
         *
         * Overview:
         *
         * ```
         *   ┌────────────── second (optional)
         *   │ ┌──────────── minute
         *   │ │ ┌────────── hour
         *   │ │ │ ┌──────── day of month
         *   │ │ │ │ ┌────── month
         *   │ │ │ │ │ ┌──── day of week
         *   │ │ │ │ │ │
         *   │ │ │ │ │ │
         *   * * * * * *
         * ```
         */
        cron: string;
    } | Duration;
    /**
     * The maximum amount of time that a single task invocation can take, before
     * it's considered timed out and gets "released" such that a new invocation
     * is permitted to take place (possibly, then, on a different worker).
     */
    timeout: Duration;
    /**
     * The amount of time that should pass before the first invocation happens.
     *
     * This can be useful in cold start scenarios to stagger or delay some heavy
     * compute jobs.
     *
     * If no value is given for this field then the first invocation will happen
     * as soon as possible according to the cadence.
     */
    initialDelay?: Duration;
}
/**
 * Options that apply to the invocation of a given task.
 *
 * @public
 */
interface TaskInvocationDefinition {
    /**
     * A unique ID (within the scope of the plugin) for the task.
     */
    id: string;
    /**
     * The actual task function to be invoked regularly.
     */
    fn: TaskFunction;
    /**
     * An abort signal that, when triggered, will stop the recurring execution of
     * the task.
     */
    signal?: AbortSignal;
}
/**
 * A previously prepared task schedule, ready to be invoked.
 *
 * @public
 */
interface TaskRunner {
    /**
     * Takes the schedule and executes an actual task using it.
     *
     * @param task - The actual runtime properties of the task
     */
    run(task: TaskInvocationDefinition): Promise<void>;
}
/**
 * Deals with the scheduling of distributed tasks, for a given plugin.
 *
 * @public
 */
interface PluginTaskScheduler {
    /**
     * Schedules a task function for coordinated exclusive invocation across
     * workers. This convenience method performs both the scheduling and
     * invocation in one go.
     *
     * @remarks
     *
     * If the task was already scheduled since before by us or by another party,
     * its options are just overwritten with the given options, and things
     * continue from there.
     *
     * @param task - The task definition
     */
    scheduleTask(task: TaskScheduleDefinition & TaskInvocationDefinition): Promise<void>;
    /**
     * Creates a scheduled but dormant recurring task, ready to be launched at a
     * later time.
     *
     * @remarks
     *
     * This method is useful for pre-creating a schedule in outer code to be
     * passed into an inner implementation, such that the outer code controls
     * scheduling while inner code controls implementation.
     *
     * @param schedule - The task schedule
     */
    createScheduledTaskRunner(schedule: TaskScheduleDefinition): TaskRunner;
}

/**
 * Deals with the scheduling of distributed tasks.
 *
 * @public
 */
declare class TaskScheduler {
    private readonly databaseManager;
    private readonly logger;
    static fromConfig(config: Config, options?: {
        databaseManager?: DatabaseManager;
        logger?: Logger;
    }): TaskScheduler;
    constructor(databaseManager: DatabaseManager, logger: Logger);
    /**
     * Instantiates a task manager instance for the given plugin.
     *
     * @param pluginId - The unique ID of the plugin, for example "catalog"
     * @returns A {@link PluginTaskScheduler} instance
     */
    forPlugin(pluginId: string): PluginTaskScheduler;
}

export { PluginTaskScheduler, TaskFunction, TaskInvocationDefinition, TaskRunner, TaskScheduleDefinition, TaskScheduler };
