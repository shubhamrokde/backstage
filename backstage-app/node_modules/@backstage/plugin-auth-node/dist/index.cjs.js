'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors = require('@backstage/errors');
var jose = require('jose');
var fetch = require('node-fetch');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);

function getBearerTokenFromAuthorizationHeader(authorizationHeader) {
  if (typeof authorizationHeader !== "string") {
    return void 0;
  }
  const matches = authorizationHeader.match(/^Bearer[ ]+(\S+)$/i);
  return matches == null ? void 0 : matches[1];
}

const CLOCK_MARGIN_S = 10;
class IdentityClient {
  static create(options) {
    return new IdentityClient(options);
  }
  constructor(options) {
    this.discovery = options.discovery;
    this.issuer = options.issuer;
    this.keyStore = new jose.JWKS.KeyStore();
    this.keyStoreUpdated = 0;
  }
  async authenticate(token) {
    var _a;
    if (!token) {
      throw new errors.AuthenticationError("No token specified");
    }
    const key = await this.getKey(token);
    if (!key) {
      throw new errors.AuthenticationError("No signing key matching token found");
    }
    const decoded = jose.JWT.IdToken.verify(token, key, {
      algorithms: ["ES256"],
      audience: "backstage",
      issuer: this.issuer
    });
    if (!decoded.sub) {
      throw new errors.AuthenticationError("No user sub found in token");
    }
    const user = {
      id: decoded.sub,
      token,
      identity: {
        type: "user",
        userEntityRef: decoded.sub,
        ownershipEntityRefs: (_a = decoded.ent) != null ? _a : []
      }
    };
    return user;
  }
  async getKey(rawJwtToken) {
    const { header, payload } = jose.JWT.decode(rawJwtToken, {
      complete: true
    });
    const keyStoreHasKey = !!this.keyStore.get({ kid: header.kid });
    const issuedAfterLastRefresh = (payload == null ? void 0 : payload.iat) && payload.iat > this.keyStoreUpdated - CLOCK_MARGIN_S;
    if (!keyStoreHasKey && issuedAfterLastRefresh) {
      await this.refreshKeyStore();
    }
    return this.keyStore.get({ kid: header.kid });
  }
  async listPublicKeys() {
    const url = `${await this.discovery.getBaseUrl("auth")}/.well-known/jwks.json`;
    const response = await fetch__default["default"](url);
    if (!response.ok) {
      const payload = await response.text();
      const message = `Request failed with ${response.status} ${response.statusText}, ${payload}`;
      throw new Error(message);
    }
    const publicKeys = await response.json();
    return publicKeys;
  }
  async refreshKeyStore() {
    const now = Date.now() / 1e3;
    const publicKeys = await this.listPublicKeys();
    this.keyStore = jose.JWKS.asKeyStore({
      keys: publicKeys.keys.map((key) => key)
    });
    this.keyStoreUpdated = now;
  }
}

exports.IdentityClient = IdentityClient;
exports.getBearerTokenFromAuthorizationHeader = getBearerTokenFromAuthorizationHeader;
//# sourceMappingURL=index.cjs.js.map
